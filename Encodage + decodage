from PIL import Image

# fonction qui transforme une image en une liste de pixels rgba
def convert_image_pixel(file):
    image = Image.open(file)
    image = image.convert('RGBA')
    liste_pixels = list(image.getdata())
    return liste_pixels

# fonction qui decode le nombre de pixels utilises dans l'encodage
def nb_pixels_encodes(image):
    # recuperer la liste des pixels rgba decimal d'une image
    liste_pixels = convert_image_pixel(image)
    # initialiser une liste qui va contenir les bits necessaires pour avoir
    # le nombre de pixels utilises dans l'encodage (a l'envers)
    liste_bit = []
    for i in range(8):
        for k in range(4):
            bit = liste_pixels[-i][-k] % 2
            liste_bit.append(bit)
    # remettre la liste des bits a l'endroit
    liste_bit.reverse()
    # transformer la liste en une chaine de caractere
    nombre_bin = ''
    for bit in liste_bit:
        nombre_bin += str(bit)
    # transformer le nombre de pixel en decimal
    nombre_pixels_utilises = int(nombre_bin, 2)
    return nombre_pixels_utilises


# fonction qui decode le message cache dans l'image
def decodage(image):
    # liste des pixels (en rgba) qui constituent l'image
    liste_pixels_rgba = convert_image_pixel(image)
    # nombre de pixels utilises pour encoder le messsage
    nb_pixels = 118 # a completer lorsque l'encodage est termine
    # initialiser une liste qui contient les bits necessaires pour le decodage
    message_bin = []
    # recuperer les bits necessaires pour le decodage
    for i in range(nb_pixels):
        for k in range(4):
            bit = liste_pixels_rgba[i][k] % 2
            message_bin.append(bit)
    # initialiser une nouvelle liste qui va contenir les bits regroupes en 8
    message_bin_8 = []
    while len(message_bin) > 0:
        lettre_bin = ''
        for i in range(8):
            lettre_bin += str(message_bin[i])
        message_bin_8.append(lettre_bin)
        del message_bin[0:8]
    # initialiser une nouvelle liste qui va contenir les nombres decimaux correspondant a chaque caractere
    message_ascii = []
    for bits8 in message_bin_8:
        message_ascii.append(int(bits8, 2))
    # initialiser une nouvelle liste qui va contenir les caracteres du message encodes
    message_unicode = []
    for nbr in message_ascii:
        message_unicode.append(chr(nbr))
    # transformer la liste en une chaine de caractere
    message = ''
    for caractere in message_unicode:
        message += caractere
    return message

# fonction qui encode un message dans une image
def traitement_image(file, texte):
    liste_binaire=[]
    im = Image.open(file)
    im = im.convert('RGBA')
    #join() sert a concatener des strings, .format() convertit du ASCII en binaire et ord convertit le Unicode en ASCII
    w_img=(im.size)[0]
    h_img=(im.size)[1]
    binaire=''.join(format(ord(i), '08b') for i in texte)#la variable binaire est un string de binaire correspondant au texte donne en argument
    for i in range(len(binaire)):
        liste_binaire.append(int(binaire[i])) #liste_binaire est une liste contenant des strings. chaque string est un nombre en binaire
    nb_pixels = len(liste_binaire)//4
    for k in range(nb_pixels):
        coordinate = x, y = k % w_img, k//w_img # on place les bits en partant du pixel en haut a droite. on incremente de un a un vers la gauche jusqua toucher la limite droite, on revient ensuite a gauche en descendant d'une ligne. donc l'abscisse est de k modulo la largeur de l'image, et l'ordonnee est la division entiere de k par la largeur de l'image.
        tpl = im.getpixel(coordinate)
        couleur = list(tpl)
        couleur_bin = [int((bin(couleur[0]))[2:10]), int((bin(couleur[1]))[2:10]), int((bin(couleur[2]))[2:10]),int((bin(couleur[3]))[2:10])] #couleur_bin est une liste. les valeurs prises sont 'couleur' en binaire, string, auquel on enleve le '0b' du debut(avec un slice), et qu'on reconvertit en string
        for i in range(4):
            if liste_binaire[4*k+i] != couleur_bin[i] % 2:
                couleur_bin[i]=str((couleur_bin[i]//10)*10+liste_binaire[4*k+i])
                couleur_bin[i]=int((couleur_bin)[i],2)
            else:
                couleur_bin[i]=int(str(couleur_bin[i]),2)
        couleur_bin=tuple(couleur_bin)
        im.putpixel(((k % w_img),(k//w_img)),couleur_bin)
    nb_pixels=bin(len(texte)*2) #multiplie par 2 car il faut 2 pixels pr stocker un caractere
    nb_pixels=''.join(format(ord(i), '08b') for i in nb_pixels)
    while len(nb_pixels)<16:
        nb_pixels=0+nb_pixels
    nb_pixels=bin(len(texte)*2) #multiplie par 2 car il faut 2 pixels pr stocker un caractere
    nb_pixels=''.join(format(ord(i), '08b') for i in nb_pixels)
    while len(nb_pixels)<64:
        nb_pixels='0'+nb_pixels
    im.show()
    im.save('pigeon_encode.png')

# programme principal
traitement_image('pigeon.png', 'Paris a gagne')
print(decodage('pigeon_encode.png'))
